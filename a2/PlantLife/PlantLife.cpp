/***********************************************************
           CSC418/2504, Winter 2017, St. George
                 PlantLife.cpp

  Learning Goals:

   After completing this assignment you should be able to

   * Design and implement objects as a hierarchy or parts
     related by transformations
   * Do simple animation of hierarchical objects
   * Understand how plant structures can be generated by
     using a small set of rules working on strings of
     symbols
   * Understand and use illumination in OpenGL
   * Use simple functions to generate a ground surface map.

  What to do:

   * Read the handout! it contains important details about
     the work you are supposed to do here and explains
     how L-systems (used to generate the plants) work.
   * Read the comments in this starter file, which detail
     what the existing code does and indicate what needs
     doing.
   * Complete all the parts marked // TO DO:
   * Add any // CRUNCHY:  extensions you want
   * Test thoroughly and make sure it works on CDF
   * Complete the CHECKLIST and REPORT files!

Program Code V3.0: F. Estrada, Sep 2012.
***********************************************************/

// OpenGL libraries
#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glut.h>
#include <imgui.h>
#include "imgui_impl_glut.h"
#include <iostream>

// Standard UNIX/C libraries
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <unistd.h>

#define MAX_PLANTS 25		// Maximum number of plants for plant forests
#define GRID_RESOLVE 64		// Size of the surface grid
#define FLOWER_COL 2
#define BOID_NUM 100
#define nTrace 20
const float PI = 3.14159;
/******************************************************************************
  Data structures section
*******************************************************************************/
// Tree structure used to hold the plant model for rendering (remember the
// hierarchical rendering we discussed in tutorial, and you used for A1!)
struct PlantNode{
  char type;         // Node type, a=stem, b=stem, c=leaf, d=flower    - You may add your own types as needed
  //in degree
  GLfloat z_ang;     // Rotation of this node w.r.t. parent's z-axis   - Rotates around the current stem direction
  GLfloat x_ang;     // Rotation of this node w.r.t. parent's x-axis   - Rotates away from current stem direction
  GLfloat scl;       // Local scale for this node

  GLfloat f_c_R;     // Colour for this node's component - You can use it if needed, for example, to give
  GLfloat f_c_G;     // flowers different colours.
  GLfloat f_c_B;
  GLint misc_A;	     // Misc variables A to C are UNDEFINED. You can use them any way you want to create
  GLint misc_B;      // different types of structures for the stems, leafs, and flowers.
  GLint misc_C;
  int animt_lev;    // used to randomize the growth speed for each tree

  struct PlantNode *left;     // Left child for this node (NULL means the node is a terminal)
  struct PlantNode *right;    // Right child for this node (NULL means the node is a terminal)

  // QUESTION: We don't have a translation component... WHY?
  // Answer: Because we don't know the transformation of the parent, we don't know how much to
  // translate in the local coordinate. It has to be done in the parent world frame, i.e. by hierachy.

  // NOTE: We don't have pointers to the parents. Make sure your drawing function knows what
  // it's doing!
};

GLfloat brown3fv[3] = {0.55, 0.27, 0.07};
GLfloat coral3fv[3] ={1,0.5,0.3};
GLfloat pinkish[FLOWER_COL][3] = {{1,0.5,0.3},{0.86,0.08,0.24}}; //coral, crimson
GLfloat groundColor[2][3] = { {0.6, 0.2, 0.2},{0.6, 0.4, 0.2}};
int old_mousePos[2];
bool drag_valid;
ImVec2 windowPos;
ImVec2 windowSize;
/******************************************************************************
  Global data
******************************************************************************/
struct PlantNode *PlantForest[MAX_PLANTS];	// Array of pointers for a plant forest, use when drawing multiple plants
int ForestXYZ[MAX_PLANTS][2];		// Location of plants in the forest as (index_x, index_y)
GLfloat GroundXYZ[GRID_RESOLVE][GRID_RESOLVE][3];	// Array to store ground surface points as (x,y,z) points
GLfloat GroundNormals[GRID_RESOLVE][GRID_RESOLVE][3];   // Array to hold normal vectors at vertices (will use normal to triangle
                                                        // defined by the vertices at [i][j], [i+1][j], and [i][j+1]
GLfloat const leaf[4][3]={{0,0,0},{0,1,0},{0,1,1},{0,0,1}};
GLfloat leaf_normal[3]={1,0,0};

GLfloat Boid_Location[BOID_NUM][3];
GLfloat Boid_trace[BOID_NUM][nTrace][3];

ImVec4 clear_color = ImColor(0.1f,0.1f,0.1f,1.0f);

// Texture data
static bool textures_on;				// Flag to indicate texturing should be enabled for leafs/flowers
GLuint l_texture,g_texture,t_texture;				// Identifiers for OpenGL texture data for leaf and ground and tree bark
int l_sx,l_sy,g_sx,g_sy;
unsigned char *leaf_texture;			// Pointer to leaf texture data (RGBA)
unsigned char *ground_texture;			// Pointer to ground texture data (RGBA)

//Animation data
static int Opening_animation=1;    
int Snow=1;
int snow_h = 20;
int leaf_down = 0; // 0 means ang_x < 90 degrees
		   // 1 means ang_x > 90 degrees


// Window settings and GLUI variables
int windowID;               // Glut window ID (for display)
int Win[2];                 // window (x,y) size

// GLUI interface variables
GLfloat global_Z;	    // User controlled global rotation around Z
GLfloat global_scale;       // User controlled global scale factor
float ground_scale;
float ground_coef1;
float ground_coef2;
int gc=0;

// Command-line parameters - These affect the shape of the plants, and control the number of plants in the forest
GLfloat Z_angle;      // Max angle around local Z-axis for each level
GLfloat X_angle;      // Max angle around local X-axis at each branching point
GLfloat scale_mult;   // Scale multiplier for children. Children nodes have scale=(scale_mult*parent_scale);
GLint n_levels;       // Number of levels of branching in the plant
GLint n_plants;	      // Number of plants in a plant forest in [1,MAX_PLANTS]

// Transition probabilities for the L-system specification
GLfloat Paaa;
GLfloat Paab;
GLfloat Paac;
GLfloat Paad;
GLfloat Pacd;
GLfloat Pba;
GLfloat Pbc;
GLfloat Pbd;

/******************************************************************************
  Function Prototypes
*******************************************************************************/
// Initialization functions
void initGlut(char* winName);
unsigned char *readPPM(const char *name, int *sx, int *sy);

// Callbacks for handling events in glut
void WindowReshape(int w, int h);
void WindowDisplay(void);
void MouseClick(int button, int state, int x, int y);
void MotionFunc(int x, int y) ;
void PassiveMotionFunc(int x, int y) ;
void KeyboardPress(unsigned char key, int x, int y);
void KeyboardPressUp(unsigned char key, int x, int y);

// L-system generation, rendering, and animation
struct PlantNode *MakePlant(void);
void GenerateRecursivePlant(struct PlantNode *p, int level);
void FreePlant(struct PlantNode *p);
void PrintPlant(struct PlantNode *p);
void printNodeRecursive(struct PlantNode *p, int lev, int tgt);
void RenderPlant(struct PlantNode *p, bool root);
void StemSection();
void LeafSection();
void FlowerSection();
void AnimatedRenderPlant();
void RenderLevel(struct PlantNode *p, int cur, int tgt);

// Surface generation
void MakeSurfaceGrid(void);
void RenderSurfaceGrid(void);
void computeNormal(double *vx, double *vy, double *vz, double wx, double wy, double wz);

// Drawing functions
void draw_polygon();
void draw_textured_polygon(GLuint txt);
void draw_snowTrace(int i);
void update_snow(int i);

//Dear Imgui functions
static void ShowHelpMarker(const char* desc);
void setupUI();

/**************************************************************************
 Program Code starts
**************************************************************************/
void computeNormal(double *vx, double *vy, double *vz, double wx, double wy, double wz)
{
 //
 // I'm giving you a handy small function to compute the normal to a surface
 // given two vectors known to be on that surface (e.g. two sides of a GL_QUAD
 // or GL_TRIANGLE).
 //
 // Notice that it returns the normal in vx, vy, vz, hence these are expected
 // to be pointers
 //
 // Example call:
 //     vx = .25;
 //     vy = .12;
 //     vz = -.1;
 //     wx = .5;
 //     wy = -.3;
 //     wz = .25;
 //     computeNormal(&vx, &vy, &vz, wx, wy, wz);
 //
 // The returned normal has unit length.
 //

 double len;
 double nx,ny,nz;

 len=sqrt(((*vx)*(*vx))+((*vy)*(*vy))+((*vz)*(*vz)));
 *(vx)=(*vx)/len;
 *(vy)=(*vy)/len;
 *(vz)=(*vz)/len;

 len=sqrt((wx*wx)+(wy*wy)+(wz*wz));
 wx/=len;
 wy/=len;
 wz/=len;

 //cross product of unit v and n
 nx=((*vy)*wz)-(wy*(*vz));
 ny=(wx*(*vz))-((*vx)*wz);
 nz=((*vx)*wy)-(wx*(*vy));

 *(vx)=nx;
 *(vy)=ny;
 *(vz)=nz;
}

void restart_renderForest(){
    Opening_animation =1;
    for(int i=0; i<n_plants; ++i){
	PlantForest[i]->animt_lev = 0;
    }
}

void RenderSurfaceGrid(void)
{
 // Render the surface grid defined by the vertices in GroundXYZ
    glPushMatrix();
    if (textures_on)
    {
     glColor4f(1,1,1,1);
     glEnable(GL_TEXTURE_2D);
     // Enable Alpha-blending
     glEnable (GL_BLEND);
     glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
     glEnable(GL_CULL_FACE);
     glBindTexture(GL_TEXTURE_2D,g_texture);
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
     glTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
    }else
	glColor3fv(groundColor[gc]);

    for(int i=0; i<GRID_RESOLVE-1; ++i){
	int u = 0; //u-v coordinate
	glBegin(GL_QUAD_STRIP);

	for(int j=0; j<GRID_RESOLVE; ++j){

	    glNormal3fv(GroundNormals[i][j]);
	    if(textures_on) glTexCoord2f(u,0);
	    glVertex3fv(GroundXYZ[i][j]);

	    glNormal3fv(GroundNormals[i+1][j]);
	    if(textures_on) glTexCoord2f(u,1);
	    glVertex3fv(GroundXYZ[i+1][j]);
	}
	glEnd();
	u = u^1;
    }
    
    // Disable texture mapping
    if (textures_on)
    {
     glDisable(GL_CULL_FACE);
     glDisable(GL_TEXTURE_2D);
     glDisable (GL_BLEND);
    }

    glPopMatrix();
}

/*
void MakeLeafGrid(void){
    //I'm drawing each leaf as Cardrioid
    //x = acost(1-cost)
    //y = asint(1-cost)
}
*/

void MakeSurfaceGrid(void)
{
 // Generate an interesting surface to place the plants on

 /////////////////////////////////////////////////////////////////////////
 //       Generate a surface map. I am already giving you
 //
 //       Interesting surface (not random, and not a simple sphere, plane,
 //       or saddle. Use your imagination and knowledge of parametric
 //       surfaces, or do a bit of research into terrain generation.
 //
 //       NOTE: when you assign locations to the plants in your forest,
 //             make sure the pant's root location agrees with the
 //             surface height at the point where it is rooted.
 //             We don't want plants sinking into the ground!
 /////////////////////////////////////////////////////////////////////////
 double side;

 // Assign surface heights
 side=15;				// Width of the surface - X and Y coordinates
					// will have values in [-side/2, side/2]
 for (int i=0; i<GRID_RESOLVE; i++)
  for (int j=0; j<GRID_RESOLVE; j++)
  {
   GroundXYZ[i][j][0]=(-side*.5)+(i*(side/GRID_RESOLVE));
   GroundXYZ[i][j][1]=(-side*.5)+(j*(side/GRID_RESOLVE));
   GroundXYZ[i][j][2]=0;	// <----- HERE you must define surface height in some smart way!
   //I'm using a parametraized function for the height
   //z = x^2 + y^2 + side/2*sin(xy)
   GroundXYZ[i][j][2]= GroundXYZ[i][j][0]*GroundXYZ[i][j][0] +
			GroundXYZ[i][j][1]*GroundXYZ[i][j][1] +
			ground_coef1*sin(GroundXYZ[i][j][0]*GroundXYZ[i][j][1]*ground_coef2);
    GroundXYZ[i][j][2]*=ground_scale; //scale it!
  }

 // Compute normals at each vertex
 //
 // NOTE: Be careful with indexing along the borders of the surface grid! you will
 //       run into all sorts of problems if you don't think carefully what you're
 //       doing.
 //
 // Since I'm using a parametrized functin, the normal is simply
 // calculated from the formula, including the boundary points.
 double vx,vy,vz,wx,wy,wz, x, y;
 for (int i=0; i<GRID_RESOLVE; i++)
  for (int j=0; j<GRID_RESOLVE; j++)
  {
	x = GroundXYZ[i][j][0];
	y = GroundXYZ[i][j][1];
	//the tangent vectors by taking derivatives
	vx = 1;
	vy = 0;
	vz = 2*x+ground_coef1*ground_coef2*y*cos(x*y*ground_coef2);
	vz*= ground_scale;
	wx = 0;
	wy = 1;
	wz = 2*y+ground_coef1*ground_coef2*x*cos(x*y*ground_coef2);
	wz *= ground_scale;

	// Then compute the normal
     	computeNormal(&vx,&vy,&vz,wx,wy,wz);

     	// And store it...
     	GroundNormals[i][j][0]=vx;
     	GroundNormals[i][j][1]=vy;
     	GroundNormals[i][j][2]=vz;
  }
}


void SetglModelView(){
    // Clear colour buffer and Z-buffer
    glClearColor(clear_color.x, clear_color.y, clear_color.z, clear_color.w);
    // Clear the screen and depth buffers
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    // Setup the model-view transformation matrix
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    glClearDepth(1);
    glEnable(GL_DEPTH_TEST);    // Enable depth testing
    glEnable(GL_LIGHTING);      // Enable lighting
    glEnable(GL_LIGHT0);        // Set up 1 light sources, 1 for diffuse,
    glEnable(GL_LIGHT1);        // 1 for ambient

    glEnable(GL_NORMALIZE);	// Make sure normals stay normalized...

    // Set up light source colour, type, and position
    GLfloat light0_colour[]={.95,.95,.95};
    GLfloat light1_colour[]={.05,.05,.05};
    glLightfv(GL_LIGHT0,GL_DIFFUSE,light0_colour);
    glLightfv(GL_LIGHT1,GL_AMBIENT,light1_colour);
    GLfloat light0_pos[]={2,2,5,0};
    glLightfv(GL_LIGHT0,GL_POSITION,light0_pos);
    glShadeModel(GL_SMOOTH);

    // Enable material colour properties
    glEnable(GL_COLOR_MATERIAL);

    //zoom and rotate camera
    glScalef(global_scale,global_scale,global_scale);
    glRotatef(global_Z,0,0,1);
 

}

// This function animates the growth of all plants in the plant
// forest.
// This function animate by posting display event to return control.
// This way allows user to rotate and zoom during the animation
void AnimatedRenderPlant()
{
    bool done = true;

    /***** Scene drawing start *********/
    clock_t start = clock(), now;
    RenderSurfaceGrid();

    for (int i=0; i<n_plants; i++)
    {
      if(PlantForest[i]->animt_lev < n_levels) done = false;

      glPushMatrix();
      int treex = ForestXYZ[i][0];
      int treey = ForestXYZ[i][1];

      glTranslatef(GroundXYZ[treex][treey][0],GroundXYZ[treex][treey][1],
      		GroundXYZ[treex][treey][2]);
		
      RenderLevel(PlantForest[i], 0, PlantForest[i]->animt_lev);

      glPopMatrix();

      //grow the level
      PlantForest[i]->animt_lev += rand()%2;
    }

    //delay to smooth animation
    do{
    	now = clock() - start;
    } while (now*10 < CLOCKS_PER_SEC);

    if(done)
	Opening_animation=0;

    //return control to the main event loop
    glutPostRedisplay();
}


void RenderLevel(struct PlantNode *p, int cur, int tgt){
    if (p==NULL) return;		// Avoid crash if called with empty node
    if(cur == tgt) return; //only draw up to this level
    if(cur > tgt) {
	printf("Incorrect level in RenderLevel\n"
	    "the final effect may look wrong\n");
    }

    glPushMatrix();

    //root is level 0 and don't need this translation
    if(cur>0){  
	//each stem has height of 1 unit
    	glTranslatef(0,0,1);
    }

    glRotatef(p->z_ang, 0, 0, 1);
    glRotatef(p->x_ang, 1, 0, 0);
    glScalef(p->scl, p->scl, p->scl);

    if(p->type == 'c'){
	//draw leaf
	LeafSection();
	glPopMatrix();
	return;
    }
    else if(p->type == 'd'){
	//draw flower
	
    	//first draw a single stem
	glScalef(0.5, 0.5, 0.5);
       	glColor3f(.25,1,.5);
       	StemSection();
       	//each stem has height of 1 unit
       	glTranslatef(0,0,1);
	//set the color of flower
	glColor3f(p->f_c_R,p->f_c_G,p->f_c_B);
	FlowerSection();

	glPopMatrix();
	return;
    }
    else if(p->type == 'a'){
	//draw a type stem
	glColor3fv(brown3fv);
	StemSection();

    }else{
	//draw b type stem
	glColor3fv(brown3fv);
	StemSection();
    }

    ////////////////////////////////////////////////////////////
    // NOTE: Since the plant has a pre-defined number of levels,
    //       many 'branches' will end in a symbol corresponding
    //       to a stem section (a or b). You should draw
    //       something at the end of these last-level stems,
    //       else your plant will look 'dried up'.
    //       
    //       If the function comes here, this node has to be
    //       a branch. Check if its children are null then draw 
    //       a leaf.
    ////////////////////////////////////////////////////////////
    if((cur+1==tgt) ||   //if this is the last level to draw
	(p->right==NULL && p->left==NULL)){
	//draw a leaf
	LeafSection();
	glPopMatrix();
	return;
    }

    //draw its children
    RenderLevel(p->right, cur+1, tgt);
    RenderLevel(p->left, cur+1, tgt);
    glPopMatrix();
    return;
}   




// Recursive rendering function for the plant. Renders the
// section specified by p after performing the transformations
// required to give this part the correct orientation and
// position.
void RenderPlant(struct PlantNode *p, bool root)
{
    if (p==NULL) return;		// Avoid crash if called with empty node

    glPushMatrix();

    if(!root){
	//each stem has height of 1 unit
    	glTranslatef(0,0,1);
    }

    glRotatef(p->z_ang, 0, 0, 1);
    glRotatef(p->x_ang, 1, 0, 0);
    glScalef(p->scl, p->scl, p->scl);

    if(p->type == 'c'){
	//draw leaf
	LeafSection();
	glPopMatrix();
	return;
    }
    else if(p->type == 'd'){
	//draw flower
	
    	//first draw a single stem
	glScalef(0.5, 0.5, 0.5);
       	glColor3f(.25,1,.5);
       	StemSection();
       	//each stem has height of 1 unit
       	glTranslatef(0,0,1);
	//set the color of flower
	glColor3f(p->f_c_R,p->f_c_G,p->f_c_B);
	FlowerSection();

	glPopMatrix();
	return;
    }
    else if(p->type == 'a'){
	//draw a type stem
	glColor3fv(brown3fv);
	StemSection();

    }else{
	//draw b type stem
	glColor3fv(brown3fv);
	StemSection();
    }

    ////////////////////////////////////////////////////////////
    // NOTE: Since the plant has a pre-defined number of levels,
    //       many 'branches' will end in a symbol corresponding
    //       to a stem section (a or b). You should draw
    //       something at the end of these last-level stems,
    //       else your plant will look 'dried up'.
    //       
    //       If the function comes here, this node has to be
    //       a branch. Check if its children are null then draw 
    //       a leaf.
    ////////////////////////////////////////////////////////////
    if(p->right==NULL && p->left==NULL){
	//draw a leaf
	LeafSection();
	glPopMatrix();
	return;
    }

    //draw its children
    RenderPlant(p->right, false);
    RenderPlant(p->left, false);
    glPopMatrix();
    return;
}

//color should be set by the caller
void draw_textured_polygon(GLuint txt){
    glPushMatrix();
    glScalef(2,2,2);
    glBindTexture(GL_TEXTURE_2D, txt);

    glBegin(GL_POLYGON);
    //this needs a large improvement -- F3
    glNormal3fv(leaf_normal);

    glTexCoord2f(0,1);
    glVertex3fv(leaf[0]);

    glTexCoord2f(1,1);
    glVertex3fv(leaf[1]);

    glTexCoord2f(1,0);
    glVertex3fv(leaf[2]);

    glTexCoord2f(0,0);
    glVertex3fv(leaf[3]);

    glEnd();
    glPopMatrix();
}

//arg -- texture identifier
void draw_polygon(){
    glPushMatrix();
    glBegin(GL_POLYGON);

    //this can use a large improvement -- F3
    glNormal3fv(leaf_normal);
    int i=0;
    while(i<4){

    	glVertex3fv(leaf[i]);
	++i;
    }
    glEnd();
    glPopMatrix();
}

void StemSection(void)
{
  // Draws a single stem section, along the current local Z axis
  // I'm giving you this function already so you can at least see
  // the 'skeleton' of your plant to help debug the L-system.

  // Create a quadrics object to make the stem
  GLUquadric *quadObject;
  quadObject=gluNewQuadric();

  gluCylinder(quadObject,.05,.04,1,10,10);

  // Destroy our quadrics object
  gluDeleteQuadric(quadObject);
}


////////////////////////////////////////////////////////////
 //        Instructor's note:
 //        How to obtain the leaf's vertext coordinates?
 //        I use quadriculated paper...
 ////////////////////////////////////////////////////////////


void LeafSection(void)
{
 glPushMatrix();
 // Draws a single leaf, along the current local Z axis
 // Note that we draw a little stem before the actual leaf.
 glColor3fv(brown3fv);
 glScalef(1, 1, 0.2);
 StemSection();
 glPopMatrix();

 glPushMatrix();
 // each stem has height of 1*0.2 unit
 glTranslatef(0,0,0.2);

 // rotate away from the stem so that the
 // leaf will point *away* from the growing plant
 float x_ang = 30; //this can be randomized -- F1
 glRotatef(leaf_down*90.0f+x_ang, 1, 0, 0);
 glScalef(1,0.2,0.5);
 //I didn't do z_ang, you can add it later (randomized) -- F2

 //draw textures-off leaf
 if(!textures_on){
    glColor3f(.25,1,.1);
    glRotatef(45, 1,0,0);
    draw_polygon();
 }else{
    //use texture mapping
    glEnable(GL_TEXTURE_2D);
    glEnable(GL_BLEND); // Enable Alpha-blending
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    //glEnable(GL_CULL_FACE); //Fan: you may want to disable this to be able to render both sides
    glBindTexture(GL_TEXTURE_2D,l_texture);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);

    //draw a square
    //for some reason, the color has to be set for the texture to show the color
    glColor4f(1,1,1,1);
    draw_textured_polygon(l_texture);

    // Disable texture mapping
    glDisable(GL_CULL_FACE);
    glDisable(GL_TEXTURE_2D);
    glDisable (GL_BLEND);
 }

 glPopMatrix();
}

void FlowerSection()
{
 int const pedals = 5;
 float ang=360/pedals;

 // Draws a flower perpendicular to the current local Z axis
 for(int i=0;i<pedals;++i){
    glPushMatrix();
    glRotatef(i*ang,0,0,1);
    glRotatef(-90.0f,0,1,0);
    glScalef(1,0.2,0.5);
    glRotatef(45, 1,0,0);
    draw_polygon();
    glPopMatrix();
 }

 /////////////////////////////////////////////////////////////
 // CRUNCHY: Use texture mapping to create nicer flowers!
 //          Should be easy if you already texture mapped
 //          the leaves.
 /////////////////////////////////////////////////////////////

 // Enable texture mapping (you must also enable it in main()! )
 /*
 if (textures_on)
 {
  glEnable(GL_TEXTURE_2D);
  // Enable Alpha-blending
  glEnable (GL_BLEND);
  glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  glEnable(GL_CULL_FACE);
  glBindTexture(GL_TEXTURE_2D,p_texture);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
  glTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
 }
 // Disable texture mapping
 if (textures_on)
 {
  glDisable(GL_CULL_FACE);
  glDisable(GL_TEXTURE_2D);
  glDisable (GL_BLEND);
 }
*/
}

void FreePlant(struct PlantNode *p)
{
 // Release all memory allocated to the plant structure
 if (p==NULL) return;
 if (p->left!=NULL) FreePlant(p->left);
 if (p->right!=NULL) FreePlant(p->right);
 free(p);
}

void PrintPlant(struct PlantNode *p)
{
 // Tree traversal to print the plant structure
 // To enable viewing the structure of the plant,
 // Nodes are printed by level, note that this is
 // different from what you may need to do to
 // render the plant (which would be a depth-first
 // hierarchical structure)
 int l;

 for (l=0;l<n_levels;l++)
 {
  fprintf(stderr,"Level %02d\n",l);
  printNodeRecursive(p,0,l);
  fprintf(stderr,"\n");
 }

}

void printNodeRecursive(struct PlantNode *p, int lev, int tgt)
{
 if (p==NULL) return;
 if (lev==tgt)
 {
  fprintf(stderr,"%c ",p->type);
  return;
 }

 if (p->left!=NULL) printNodeRecursive(p->left,lev+1,tgt);
 if (p->right!=NULL) printNodeRecursive(p->right,lev+1,tgt);

 fprintf(stderr," ");
 return;
}

struct PlantNode *MakePlant(void)
{
  // This function creates a plant with the specified
  // characteristics given by the global plant parameters
  // and a set of internal parameters that govern the
  // probability of specific parts being generated
  // at each level.
  //
  // The rules for generating the plant are as follows:
  //
  // Four types of components:  a - Plant stem
  //                            b - Plant stem
  //                            c - Leaf
  //                            d - flower
  //
  // You will use the node types to render each plant
  // component appropriately.
  //
  // The generation rules for the plant structure are
  //
  // a -> aa with p = Paaa
  // a -> ab with p = Paab
  // a -> ac with p = Paac
  // a -> ad with p = Paad
  // a -> cd with p = Pacd
  // b -> a  with p = Pba
  // b -> c  with p = Pbc
  // b -> d  with p = Pbd
  // c and d are terminal nodes.
  //
  // The probabilities for transitions are parameters to
  // the function so that you can generate different
  // types of plants. 
  //
  // NOTE: The transition probabilities from a *MUST*
  // add up to 1. The transition probabilities from
  // b *MUST* also add up to 1.
  // Also, because of the probabilistic nature of the
  // generation process, you can not guarantee the plant
  // will have the specified numer of levels!
  //
  // If you add your own node types, you will have to 
  // update the generation rules, and add appropriate
  // parameters to determine transition probabilities
  // for any additional components.
  //
  // Finally, the random number seed is set in main(), 
  // but could be made an input parameter to obtain more
  // random behaviour.

  struct PlantNode *p_root=NULL;

  p_root=(struct PlantNode *)calloc(1,sizeof(struct PlantNode)); // Allocate new tree root
  p_root->type='a';                                              // Always start with a stem
  p_root->z_ang=0;                                               // which is vertical w.r.t
  p_root->x_ang=0;                                               // global coordinate frame
  p_root->scl=.8+(.2*drand48());                                 // Initial scale (defines the size
                                                                 // of the largest component).
  p_root->animt_lev=0;

  p_root->left=NULL;
  p_root->right=NULL;

  // Generative part, use the laws above to generate up to two children for each node in the tree
  GenerateRecursivePlant(p_root,1);  // Level 0 is the root, next level is 1
  return(p_root);
}

void GenerateRecursivePlant(struct PlantNode *p, int level)
{
  // Generates child nodes for parent 'p' with p being at level 'level'
  // if level>n_levels, stop.
  float dice;
  struct PlantNode *q, *r;
  
  q=r=NULL;

  if (p==NULL) return;                     // Reached a terminal
  if (p->type=='c') return;                // c and d type nodes are terminal nodes as well
  if(p->type=='d'){
    //set the flower color
    int index = drand48()*(float)FLOWER_COL;
    p->f_c_R = pinkish[index][0];
    p->f_c_G = pinkish[index][1];
    p->f_c_B = pinkish[index][2];
    return;
  }
  if (level>=n_levels) return;             // Reached maximum plant height

  dice=drand48();           // Roll the dice...
  if (p->type=='a')
  {
    // Generate 2 nodes for right and left
    q=(struct PlantNode *)calloc(1,sizeof(struct PlantNode));
    r=(struct PlantNode *)calloc(1,sizeof(struct PlantNode));
    q->x_ang=drand48()*X_angle;
    q->z_ang=drand48()*Z_angle;
    q->animt_lev=0;
    q->scl=scale_mult;
    //q->scl=scale_mult*p->scl;
    q->left=NULL;
    q->right=NULL;
    r->x_ang=drand48()*X_angle;
    r->z_ang=drand48()*Z_angle;
    r->animt_lev=0;
    r->scl=scale_mult;
    //r->scl=scale_mult*p->scl;
    r->left=NULL;
    r->right=NULL;

    if(dice<=Pacd){
	// Selected rule a -> cd
	q->type='c';
	r->type='d';
    }else {
	// Selected rule a -> a%
	q->type='a';

	if(dice<=(Pacd+Paaa))
	    r->type='a';
	else if(dice<=(Pacd+Paaa+Paab))
	    r->type='b';
	else if(dice<=(Pacd+Paaa+Paab+Paac))
	    r->type='c';
	else
	    r->type='d';
    }

  }
  else if (p->type=='b')
  {
    // Generate a single node for either left or right
    q=NULL;
    r=(struct PlantNode *)calloc(1,sizeof(struct PlantNode));
    r->x_ang=drand48()*X_angle;
    r->z_ang=drand48()*Z_angle;
    r->animt_lev=0;
    r->scl=scale_mult;
    //r->scl=scale_mult*p->scl;
    r->left=NULL;
    r->right=NULL;

    if (dice<=Pba)
      {
	// Selected rule b -> a
        r->type='a';
      }
    else if (dice<=(Pba+Pbc))
      {
        // Selected rule b -> c
        r->type='c';
      }
    else
      {
        // Selected rule b -> d
        r->type='d';
      }
  }
  else {fprintf(stderr,"Bad node type!\n"); return;}

  // Decide which node goes to left and which goes right randomly
  if (drand48()<=.5)
    {
      p->left=q;
      p->right=r;
    }
  else
    {
      p->left=r;
      p->right=q;
    }

  // Recursive call for children
  GenerateRecursivePlant(p->left,level+1);
  GenerateRecursivePlant(p->right,level+1);
}

int main(int argc, char** argv)
{
 /*
   Parse input line parameters, enforce reasonable bounds on global variables
   and parameters for the L-system, and set up plant structures.
 */

    // Process program arguments
    if(argc != 16) {
        printf("Usage: PlantLife n_plants n_levels X_angle Z_angle scale_mult Paaa Paab Paac Paad Pacd Pba Pbc Pbd width height\n");
        exit(1);
    } else {
        n_plants=atoi(argv[1]);
        n_levels=atoi(argv[2]);
        X_angle=atof(argv[3]);
        Z_angle=atof(argv[4]);
        scale_mult=atof(argv[5]);
        Paaa=atof(argv[6]);
        Paab=atof(argv[7]);
        Paac=atof(argv[8]);
        Paad=atof(argv[9]);
        Pacd=atof(argv[10]);
        Pba=atof(argv[11]);
        Pbc=atof(argv[12]);
        Pbd=atof(argv[13]);
        Win[0] = atoi(argv[14]);
        Win[1] = atoi(argv[15]);

        // Enforce bounds on input variables
        if (n_plants>=MAX_PLANTS) n_plants=MAX_PLANTS;
        if (n_plants<=0) n_plants=1;
        if (n_levels<3) n_levels=3;
        if (n_levels>12) n_levels=12;
        if (X_angle<10) X_angle=50;
        if (X_angle>90) X_angle=90;
        if (Z_angle<10) Z_angle=10;
        if (Z_angle>360) Z_angle=360;
        if (scale_mult<.75) scale_mult=.75;
        if (scale_mult>.99) scale_mult=.99;
	Paaa=Paaa/(Paaa+Paab+Paac+Paad+Pacd);
	Paab=Paab/(Paaa+Paab+Paac+Paad+Pacd);
	Paac=Paac/(Paaa+Paab+Paac+Paad+Pacd);
	Paad=Paad/(Paaa+Paab+Paac+Paad+Pacd);
	Pacd=Pacd/(Paaa+Paab+Paac+Paad+Pacd);
        Pba=Pba/(Pba+Pbc+Pbd);
        Pbc=Pbc/(Pba+Pbc+Pbd);
        Pbd=Pbd/(Pba+Pbc+Pbd);
        if (Win[0]<250) Win[0]=250;
        if (Win[0]>2048) Win[0]=2048;
        if (Win[1]<250) Win[1]=250;
        if (Win[1]>1024) Win[1]=1024;

	////////////////////////////////////////////////
        // CRUNCHY - If you are going to use textures
        //           for your leafs and flowers, update
        //           the code below.
        //           Make sure the input images are
        //           available and have a square size
        //           which is a power of 2. A reasonable
        //           size would be 256x256, don't use
        //           huge textures or you'll pay in
        //           rendering performance.
	//
        //           You MUST
        //           submit your texture images along
        //           with your completed code.
        ////////////////////////////////////////////////
	textures_on=1;		// Set to 1 to enable texturing
        if (textures_on)
        {
	 leaf_texture=readPPM("leaf.ppm",&l_sx,&l_sy);	// Evidently, you must change this to be
									// your leaf texture image in .ppm format!
	 ground_texture=readPPM("ground3.ppm",&g_sx,&g_sy);	// Similarly, set this to be your petal
									// texture image.
         if (!leaf_texture||!ground_texture)
         {
          fprintf(stderr,"main(): Unable to load textures. Texture mapping disabled\n");
          textures_on=0;
         }
         else fprintf(stderr,"Textures read and stored\n");
        }
    }

    // Initialize OpenGL - Take a moment to read through these functions!
    glutInit(&argc, argv);
    initGlut(argv[0]);

    // Initialize all data arrays
    memset(&GroundXYZ[0][0][0],0,GRID_RESOLVE*GRID_RESOLVE*3*sizeof(GL_FLOAT));
    memset(&GroundNormals[0][0][0],0,GRID_RESOLVE*GRID_RESOLVE*3*sizeof(GL_FLOAT));
    memset(&ForestXYZ[0][0],0,n_plants*2*sizeof(int));

    // Generate surface map
    ground_coef1=10;
    ground_coef2=0.2;
    ground_scale=0.05;
    MakeSurfaceGrid();

    for (int i=0;i<n_plants;i++){
	// Make a plant forest!
   	PlantForest[i]=MakePlant();
	//PrintPlant(PlantForest[i]);

    //////////////////////////////////////////////////////////////
    //    Set the locations of the plants in the plant forest
    //    randomly in X,Y, but at the correct height for
    //    the corresponding location in the surface grid.
    //////////////////////////////////////////////////////////////

    	double dicex=drand48();
    	double dicey=drand48();
       	int index=(int)(dicex*(double)GRID_RESOLVE);
       	int indey=(int)(dicey*(double)GRID_RESOLVE);
    	ForestXYZ[i][0] = index;
    	ForestXYZ[i][1] = indey;
	}

    //distribute Boids evenly
    int side = (int)sqrt((GRID_RESOLVE*GRID_RESOLVE)/BOID_NUM);
    int nBoid=0;
    for (int i=0; i<GRID_RESOLVE; i+=side){
	if(i>GRID_RESOLVE) break;
      	for (int j=0; j<GRID_RESOLVE; j+=side){
	    if(j>GRID_RESOLVE) break;
	    Boid_Location[nBoid][0]=GroundXYZ[i][j][0];
	    Boid_Location[nBoid][1]=GroundXYZ[i][j][1];
	    Boid_Location[nBoid][2]=GroundXYZ[i][j][2]+snow_h;
	    ++nBoid;
	    if(nBoid>= BOID_NUM) break;
	}
	if(nBoid>= BOID_NUM) break;
    }
    // Initialize Boid trace to its location
    for(int i=0; i<BOID_NUM; ++i){
    	for( int j = 0; j <nTrace; ++j){ 
		Boid_trace[i][j][0] = Boid_Location[i][0];
		Boid_trace[i][j][1] = Boid_Location[i][1];
		Boid_trace[i][j][2] = Boid_Location[i][2];
	}
    }


    // Intialize global transformation variables and GLUI    
    global_Z=0;
    global_scale=15;
    ImGui_ImplGlut_Init(false);

    // Invoke the standard GLUT main event loop
    glutMainLoop();
    ImGui_ImplGlut_Shutdown();
    return 0;         // never reached
}

void timerFunc(int) {
    glutTimerFunc(13,timerFunc,13);
    glutPostRedisplay();
}

// Initialize glut and create a window with the specified caption
void initGlut(char* winName)
{
    // Set video mode: double-buffered, color, depth-buffered
    glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGBA | GLUT_DEPTH);

    // Create window
    glutInitWindowPosition (0, 0);
    glutInitWindowSize(Win[0],Win[1]);
    windowID = glutCreateWindow(winName);
    drag_valid = false;

    // Setup callback functions to handle events
    glutReshapeFunc(WindowReshape);   
    glutDisplayFunc(WindowDisplay);
    glutMouseFunc(MouseClick);
    glutMotionFunc(MotionFunc);
    glutKeyboardFunc(KeyboardPress);
    glutKeyboardUpFunc(KeyboardPressUp);
    glutPassiveMotionFunc(PassiveMotionFunc);

    glutTimerFunc(13,timerFunc,13);

    // Texturing stuff - load textures to the graphics-card memory
    // once!
    if (textures_on)
    {
     //Generate and bind leaf texture
     glGenTextures( 1, &l_texture);
     glBindTexture( GL_TEXTURE_2D, l_texture);

     glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
     glTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);
     glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA, l_sx, l_sy, 0, GL_RGBA, GL_UNSIGNED_BYTE, leaf_texture);

     
     //Generate and bind flower texture
     glGenTextures( 1, &g_texture);
     glBindTexture( GL_TEXTURE_2D, g_texture);

     glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
     glTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);
     glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA, g_sx, g_sy, 0, GL_RGBA, GL_UNSIGNED_BYTE, ground_texture);
    
    }
}

//double eyePos[3] = {200, 200, 200};
double eyePos[3] = {150, 150, 150};
double center[3] = {0, 0, 50};
double up[3] = {0, 0, 1};
float fov = 60;
// Handles the window being resized by updating the viewport
// and projection matrices
void WindowReshape(int w, int h)
{
    // Setup projection matrix for new window
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();

    // We will use perspective projection. The camera is at (100,100,100)
    // looking at (0,0,0) - the origin -, with the Z axis pointing upward
    gluPerspective(fov,1,15,500);
    gluLookAt(eyePos[0], eyePos[1], eyePos[2], center[0],
    		center[1], center[2], up[0], up[1], up[2]);

    // Update OpenGL viewport and internal variables
    glViewport(0,0, w,h);
    Win[0] = w;
    Win[1] = h;
}

// Quit button handler.  Called when the "quit" button is pressed.
void quitButton(int)
{
  for (int i=0; i<n_plants; i++) FreePlant(PlantForest[i]);
  exit(0);
}

// Initialize GLUI and the user interface
void setupUI()
{
    glDisable(GL_LIGHTING);
    ImGui_ImplGlut_NewFrame();
    bool *p_open = false;
    //ImGui::ShowTestWindow(p_open);
    ImGui::Begin("PlantLife Window");

    /* Replaced with global scale
    //zoom control
    if(ImGui::DragFloat("zoom",&fov, 1.0f, 0.0f, 180.0f)){
    	int w, h;
    	w = glutGet(GLUT_WINDOW_WIDTH);
      	h = glutGet(GLUT_WINDOW_HEIGHT);
    	WindowReshape(w, h);
    }
    //ImGui::SameLine(); ShowHelpMarker("Drag to change");
    */
    ImGui::SetWindowFocus();

    windowPos = ImGui::GetWindowPos();
    windowSize = ImGui::GetWindowSize();


    //user controlled ground shape
    ImGui::Text("Ground Controller");
    ImGui::DragFloat("ground deepness", &ground_scale, 0.005f, 0.001f, 0.1f);
    ImGui::DragFloat("ground wave hight", &ground_coef1, 0.05f, 0.0f, 20.0f);
    ImGui::DragFloat("ground wave distance", &ground_coef2, 0.001f, -1.0f, 1.0f);
    if(ImGui::Button("Update Ground!"))  MakeSurfaceGrid();
    if(ImGui::Button("Switch Color")) gc = gc^1;
    ImGui::SameLine(); ShowHelpMarker("Valid when texture is OFF");
    ImGui::SameLine(); ImGui::Checkbox("Textures ON/OFF",&textures_on);
    

    ImGui::Separator();
    ImGui::Text("Animator");
    if(ImGui::Button("Grow it!")) { restart_renderForest();}
    if(ImGui::Button("Snow OFF/ON")) { Snow=Snow^1;}


    ImGui::Separator();
    ImGui::Text("Screen Controller");
    ImGui::Text("Drag on screen to rotate or drag the following");
    ImGui::DragFloat("global z rotation", &global_Z, 1.0f, -180.0f, 180.0f);
    ImGui::DragFloat("global scale", &global_scale, 0.05f, 0.0f, 20.0f);



    // Add "Quit" button
    if(ImGui::Button("Quit")) {
        quitButton(0);
    }

    //Some extra info
    ImGui::Text("Application average %.3f ms/frame (%.1f FPS)", 1000.0f / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate);


    //End window
    ImGui::End();



    ImGui::Render();
    glEnable(GL_LIGHTING);
}


void drawAxisLines(void)
{
  // Generate a set of axis at current origin so we can visualize the effect
  // of the transformations... this may be useful to you when trying to
  // figure out what is going on at different points in the plant rendering
  // process.

  // Axes are color coded X=R, Y=G, Z=B
  glColor3f(1.0,0.0,0.0);
  glBegin(GL_LINES);
  glVertex3f(0.0f, 0.0f, 0.0f);
  glVertex3f(500.0f, 0.0f, 0.0f);
  glEnd( );

  glColor3f(0.0,1.0,0.0);
  glBegin(GL_LINES);
  glVertex3f(0.0f, 0.0f, 0.0f);
  glVertex3f(0.0f, 500.0f, 0.0f);
  glEnd( );

  glColor3f(0.0,0.0,1.0);
  glBegin(GL_LINES);
  glVertex3f(0.0f, 0.0f, 0.0f);
  glVertex3f(0.0f, 0.0f, 500.0f);
  glEnd( );
}

// Main drawing function. Callback for scene display
void WindowDisplay(void)
{
    SetglModelView();

    ///////////////////////////////////////////////////////////////
    // SUPREME CRUNCHYNESS OF DOOM: (a.k.a. if you do this Paco will
    //                               be VERY impressed)
    //
    // a)  Add a button to your UI called 'scatter'. When pressed,
    //     all leafs and flowers become Boids and fly away in the
    //     typical Boid patterns from A1. Of course, you can use
    //     any of your A1 code here, and the Boid drawing function
    //     would simply be the same function that draws a leaf
    //     or a flower.
    //
    //    Notice that once the Boids are flying, the plants should
    //     have no leaves or flowers! You may want to scale your
    //     leafs/flowers so as to avoid having a bunch of huge
    //     object/Boids flying around.
    //
    //  or
    //
    //  b) Simulate the changing seasons. Leaves/petals should
    //     change colour accordingly, and fall to the ground
    //     in the fall. There should be a UI button to activate
    //     or trigger this part.
    //
    //     If you are really feeling crunchy, add some falling
    //     snow!
    //
    //     a) and b) are not mutually exclusive. More crunchy
    //     means more bonus!
    //
    //    If you are implementing this and get stuck, come and 
    //     talk to me.
    ///////////////////////////////////////////////////////////////

    if (Opening_animation)
	AnimatedRenderPlant();
    else{
       // synchronize variables that GLUT uses
       RenderSurfaceGrid();
       for (int i=0; i<n_plants; i++)
       {
         glPushMatrix();
   
         int treex = ForestXYZ[i][0];
         int treey = ForestXYZ[i][1];
   
         glTranslatef(GroundXYZ[treex][treey][0],GroundXYZ[treex][treey][1],
         		GroundXYZ[treex][treey][2]);
         RenderPlant(PlantForest[i], true);
         glPopMatrix();
       }
    }

    if(Snow){
	for(int i =0; i<BOID_NUM;++i){
	    update_snow(i);
	    draw_snowTrace(i);
	}
    }

    setupUI();
    glFlush();
    glutSwapBuffers();
    //question: is glutSwapBuffer a system call?
}

// Utility to read a .ppm file from disk for texture mapping
//sx sy stores the size of texture
unsigned char *readPPM(const char *name, int *sx, int *sy)
{
 // Reads an image from a .ppm file. A .ppm file is a very simple image representation
 // format with a text header followed by the binary RGB data at 24bits per pixel.
 // The header has the following form:
 //
 // P6
 // # One or more comment lines preceded by '#'
 // 340 200
 // 255
 //
 // The first line 'P6' is the .ppm format identifier, this is followed by one or more
 // lines with comments, typically used to inidicate which program generated the
 // .ppm file.
 //
 // After the comments, a line with two integer values specifies the image resolution
 // as number of pixels in x and number of pixels in y.
 //
 // The final line of the header stores the maximum value for pixels in the image,
 // usually 255 but does not actually matter for this code as long as it's present.
 //
 // After this last header line, binary data stores the RGB values for each pixel
 // in row-major order at 24bpp.
 //
 // readPPMdata converts the image pixel data to RGBA format by treating all
 // white pixels ([RGB]=[255,255,255]) as fully transparent. It returns an
 // array of sx * sy *4 bytes, where each pixel now has RGBA values.
 //
 // The size of the input image is returned in (sx,sy)

 FILE *f;
 unsigned char *im;
 char line[1024];
 int sizx,sizy;
 int i,j,ly;
 unsigned char *tmp;

 f=fopen(name,"r");
 if (!f){fprintf(stderr,"readPPM(): Unable to open specified image file %s\n",name);return(NULL);}

 fgets(&line[0],1000,f);
 if (strcmp(&line[0],"P6\n")!=0)
 {
  fprintf(stderr,"readPPM(): Wrong file format, not a .ppm file or header data missing\n");
  fclose(f);
  return(NULL);
 }
 // Skip over comments
 fgets(&line[0],511,f);
 while (line[0]=='#')
  fgets(&line[0],511,f);
 sscanf(&line[0],"%d %d\n",&sizx,&sizy);           // Read file size

 *(sx)=sizx;
 *(sy)=sizy;

 im=(unsigned char *)calloc(sizx*sizy*4,sizeof(unsigned char));
 tmp=(unsigned char *)calloc(sizx*sizy*3,sizeof(unsigned char));
 if (!im||!tmp)
 {
  fprintf(stderr,"readPPM(): Unable to allocate memory for image data!\n");
  free(im);
  fclose(f);
  return(NULL);
 }
 fgets(&line[0],9,f);                          		// Read the remaining header line
 fread(tmp,sizx*sizy*3*sizeof(unsigned char),1,f);	// Read image data
 fclose(f);

//My leaf color filter
bool p=false;
if(strcmp(name,"leaf.ppm")==0) p = true;

 // Convert to RGBA
 for (ly=0;ly<3;ly++)
  for (j=0;j<sizy;j++)
   for (i=0;i<sizx;i++)
   {
    *(im+((i+(j*sizx))*4)+0)=*(tmp+((i+(j*sizx))*3)+0);
    *(im+((i+(j*sizx))*4)+1)=*(tmp+((i+(j*sizx))*3)+1);
    *(im+((i+(j*sizx))*4)+2)=*(tmp+((i+(j*sizx))*3)+2);
    if ((*(tmp+((i+(j*sizx))*3)+0)==255 && *(tmp+((i+(j*sizx))*3)+1)==255 && *(tmp+((i+(j*sizx))*3)+2)==255) ||
	(p && (*(tmp+((i+(j*sizx))*3)+0)>=200 || *(tmp+((i+(j*sizx))*3)+0)>=200)))
     *(im+((i+(j*sizx))*4)+3)=0;
    else
     *(im+((i+(j*sizx))*4)+3)=192;
//if(p)   printf("(%d %d %d %d)   ",*(im+((i+(j*sizx))*4)+0),*(im+((i+(j*sizx))*4)+1),*(im+((i+(j*sizx))*4)+2),*(im+((i+(j*sizx))*4)+3));
   }
 free(tmp);
 return(im);
}

void MouseClick(int button, int state, int x, int y) {
    ImGui_ImplGlut_MouseButtonCallback(button, state, x, y);
    if(state == GLUT_DOWN){
	if((x > windowPos.x) && (x - windowPos.x < windowSize.x)
	    && (y > windowPos.y) && (y - windowPos.y < windowSize.y)){
		drag_valid = false;
		return;
	}
	drag_valid = true;
    }
    else drag_valid = false;
}

void MotionFunc(int x, int y) {
    ImGui_ImplGlut_MotionCallback(x, y);

    static bool initial=true;
    static double radiusx, radiusz, init_angx, init_angz;
    double ang = 0.017; //1 degree

    //drag to rotate the MV
    if(drag_valid){
	if(initial){
	    initial = false;
	    double delx = center[0] - eyePos[0];
	    double dely = center[1] - eyePos[1];
	    double delz = center[2] - eyePos[2];
	    radiusx = sqrt(delx*delx + dely*dely);
	    radiusz = sqrt(radiusx*radiusx + delz*delz);
	    double tanx = dely/delx;
	    double tanz = radiusx/delz;
	    init_angx = atan(tanx);
	    init_angz = atan(tanz);
	    if(delx<0) init_angx+=PI;
	}else{
		//vertical rotation
		int delta_y = y - old_mousePos[1];
		init_angz += ang*delta_y;
		if(init_angz > PI/2) init_angz = PI/2;
		else if(init_angz < -PI/2) init_angz = -PI/2;
		eyePos[2] = radiusz*cos(init_angz);

		//horizontal rotation
		radiusx = fabs(radiusz*sin(init_angz));
		int delta_x = x - old_mousePos[0];
		init_angx += ang*delta_x;
		eyePos[0] = radiusx*cos(init_angx);
		eyePos[1] = radiusx*sin(init_angx);
	}
    old_mousePos[0] = x;
    old_mousePos[1] = y;

    int w, h;
    w = glutGet(GLUT_WINDOW_WIDTH);
    h = glutGet(GLUT_WINDOW_HEIGHT);
    WindowReshape(w, h);

    }else{
	//reset the flag
    	initial = true;
    }
}
void PassiveMotionFunc(int x, int y) {
    ImGui_ImplGlut_PassiveMotionCallback(x, y);
}
void KeyboardPress(unsigned char key, int x, int y) {
    ImGui_ImplGlut_KeyCallback(key,x,y);
}
void KeyboardPressUp(unsigned char key, int x, int y) {
    ImGui_ImplGlut_KeyUpCallback(key,x,y);
}


//double compute_distance(double* a, double* b){


static void ShowHelpMarker(const char* desc)
{
    ImGui::TextDisabled("(?)");
    if (ImGui::IsItemHovered())
    {
        ImGui::BeginTooltip();
        ImGui::PushTextWrapPos(450.0f);
        ImGui::TextUnformatted(desc);
        ImGui::PopTextWrapPos();
        ImGui::EndTooltip();
    }
}

//This function draws a boid i at the specified location.
void draw_snowTrace(int i){
    for(int j=0; j<nTrace; ++j){
	glPushMatrix();
	glTranslatef(Boid_trace[i][j][0], Boid_trace[i][j][1], Boid_trace[i][j][2]);
	glColor4f(1,1,1,0.5);

	GLUquadric * my_quad = gluNewQuadric();
	gluSphere(my_quad, 0.02, 10, 10);

	gluDeleteQuadric(my_quad);
	glPopMatrix();			
     }
}

void update_snow(int i){
    const float gravity_speed=-1;
    //update the trace
    //my rule: the boid (snow) has a constant -z velocity due to the gravity
    Boid_trace[i][0][2] += gravity_speed*drand48();
    if(Boid_trace[i][0][2]<(Boid_Location[i][2]-snow_h))
	    Boid_trace[i][0][2] = Boid_Location[i][2];

    for(int j=1; j<nTrace; ++j){
    	Boid_trace[i][j][2] = Boid_trace[i][j-1][2];
    }
}
